# 无人船作业安全预测系统 - 完整工作流程

## 🚀 系统启动流程

### 1. 初始化阶段
系统启动 → 加载配置 → 创建核心组件 → 初始化通信 → 准备监控


详细步骤：
1. 配置加载
   • 加载系统配置文件 (config/system_config.json)
   • 加载通信配置 (UDP/MQTT配置)
   • 如果配置文件不存在，使用默认配置

2. 核心组件创建
   • 创建 FleetManager (舰队管理器)
   • 创建 CollisionDetector (碰撞检测器)
   • 创建通信组件 (UDPCommunicator, MQTTCommunicator)

3. 数据初始化
   • 初始化船坞信息 (DockInfo)
   • 初始化航线信息 (RouteInfo)
   • 设置告警回调函数

4. 通信系统启动
   • 初始化UDP/MQTT通信接口
   • 启动消息接收线程
   • 开始监听船只状态数据

## 🔄 核心工作循环

### 2. 数据接收与处理流程

船只数据输入 → 数据验证 → 状态更新 → 碰撞检测 → 告警生成 → 决策输出


数据流详解：

#### A. 船只状态数据输入
json
{
  "sysid": 1,                    // 船只ID
  "timestamp": 1722325256.530,   // 时间戳
  "lat": 30.549832,              // 纬度(WGS84)
  "lng": 114.342922,             // 经度(WGS84)
  "heading": 90.0,               // 航向角(度)
  "speed": 2.5,                  // 速度(m/s)
  "status": 2,                   // 状态(1-出坞,2-正常航行,3-入坞)
  "route_direction": 1           // 航线方向(1-顺时针,2-逆时针)
}


#### B. 数据验证与状态更新
• 验证数据格式和有效性
• 更新船只状态缓存 (boat_states_)
• 记录时间戳用于超时检测

#### C. 碰撞检测算法执行
系统并行执行四种碰撞检测：

## 🎯 碰撞检测算法详解

### 3. 四种碰撞检测类型

#### A. 出坞碰撞检测 (detectUndockingCollisions)
目标：检测船只驶出船坞时的碰撞风险
优先级：最低
检测逻辑：
1. 识别状态为"出坞"的船只
2. 检查船坞周围是否有其他船只
3. 计算安全出坞时间窗口
4. 生成出坞许可或等待建议


#### B. 入坞碰撞检测 (detectDockingCollisions)
目标：检测船只驶入船坞时的碰撞风险
优先级：最高
检测逻辑：
1. 识别状态为"入坞"的船只
2. 检查目标船坞是否被占用
3. 检查入坞路径是否安全
4. 为入坞船只分配船坞和路径


#### C. 前后船碰撞检测 (detectFollowingCollisions)
目标：检测同向航行船只间的碰撞风险
检测逻辑：
1. 识别同一航线上的船只
2. 计算船只间的相对距离和速度
3. 预测追尾碰撞时间
4. 根据时间阈值生成告警等级


#### D. 对向碰撞检测 (detectOncomingCollisions)
目标：检测对向航行船只的碰撞风险
检测逻辑：
1. 识别不同航线上的对向船只
2. 计算最近接近点(CPA)
3. 预测碰撞时间和位置
4. 生成避让建议


### 4. 碰撞风险计算公式

#### 时间阈值计算
cpp
// 紧急级别：碰撞距离 < 速度 × 5秒
emergency_distance = boat.speed * config.emergency_threshold_s;

// 警告级别：碰撞距离 < 速度 × 30秒  
warning_distance = boat.speed * config.warning_threshold_s;

// 告警等级判断
if (collision_distance < emergency_distance) {
    alert.level = AlertLevel::EMERGENCY;
} else if (collision_distance < warning_distance) {
    alert.level = AlertLevel::WARNING;
} else {
    alert.level = AlertLevel::NORMAL;
}


#### 几何计算
cpp
// 距离计算 (使用Haversine公式)
double distance = geometry::calculateDistance(boat1.position, boat2.position);

// 方位角计算
double bearing = geometry::calculateBearing(boat1.position, boat2.position);

// 碰撞时间预测
double collision_time = geometry::calculateCollisionTime(
    boat1.position, boat1.velocity,
    boat2.position, boat2.velocity,
    safety_radius
);


## ⚠️ 告警系统工作流程

### 5. 告警生成与处理

#### A. 告警等级定义
cpp
enum class AlertLevel {
    NORMAL = 1,      // 正常：距离 > 速度×30秒
    WARNING = 2,     // 警告：距离 < 速度×30秒
    EMERGENCY = 3    // 紧急：距离 < 速度×5秒
}


#### B. 告警信息结构
cpp
struct CollisionAlert {
    AlertLevel level;                    // 紧急程度
    int current_boat_id;                // 当前船ID
    std::vector<int> front_boat_ids;    // 前向被碰撞船ID列表
    std::vector<int> oncoming_boat_ids; // 对向被碰撞船ID列表
    GeoPoint collision_position;        // 预计碰撞位置
    double collision_time;              // 预计碰撞时间(秒)
    double current_heading;             // 当前船航向
    double other_heading;               // 对方船航向
    std::string decision_advice;        // 避碰决策建议
};


#### C. 决策建议生成
cpp
// 根据碰撞类型和风险等级生成建议
switch (collision_type) {
    case FOLLOWING:
        advice = (alert.level == EMERGENCY) ? "立即减速停船" : "减速保持安全距离";
        break;
    case ONCOMING:
        advice = (alert.level == EMERGENCY) ? "紧急右转避让" : "减速并准备避让";
        break;
    case DOCKING:
        advice = "等待入坞船只完成操作";
        break;
    case UNDOCKING:
        advice = "等待安全时机出坞";
        break;
}


## 📡 通信系统工作流程

### 6. 双协议通信架构

#### A. UDP通信流程
船只状态 → Drone ID/NMEA2000协议转换 → UDP广播 → 接收解析 → 状态更新


#### B. MQTT通信流程
船只状态 → JSON格式化 → MQTT发布 → 主题订阅 → 消息回调 → 状态更新


#### C. 通信主题结构
boat_pro/
├── boat_state/{boat_id}        # 船只状态实时发布
├── collision_alert/{boat_id}   # 碰撞告警分发
├── system_config               # 系统配置管理
├── fleet_command/{boat_id}     # 舰队命令下发
├── dock_info                   # 船坞信息同步
├── route_info                  # 航线信息同步
└── heartbeat/{boat_id}         # 心跳监控


## 🔄 优先级调度系统

### 7. 船只优先级管理

#### 优先级等级
入坞船只 (优先级 = 3) > 正常航行 (优先级 = 2) > 出坞船只 (优先级 = 1)


#### 调度逻辑
cpp
bool FleetManager::canUndock(int boat_id, int dock_id) {
    // 检查是否有高优先级船只在附近
    auto alerts = collision_detector_->detectCollisions();
    
    for (const auto& alert : alerts) {
        if (alert.current_boat_id == boat_id) {
            // 如果存在入坞或正常航行的船只冲突，拒绝出坞
            if (!alert.oncoming_boat_ids.empty() || !alert.front_boat_ids.empty()) {
                return false;
            }
        }
    }
    return true;
}


## 📊 监控与统计

### 8. 实时监控循环

#### 监控线程工作流程
cpp
void FleetManager::runSafetyMonitoring() {
    monitoring_active_ = true;
    
    std::thread monitoring_thread([this]() {
        while (monitoring_active_) {
            // 1. 执行碰撞检测
            auto alerts = collision_detector_->detectCollisions();
            
            // 2. 处理告警
            for (const auto& alert : alerts) {
                if (alert_callback_) {
                    alert_callback_(alert);  // 调用用户回调
                }
            }
            
            // 3. 短暂休眠后继续
            std::this_thread::sleep_for(std::chrono::milliseconds(100));
        }
    });
    
    monitoring_thread.detach();
}


#### 统计信息收集
• 通信统计：发送/接收数据包数量、字节数、错误数
• 告警统计：各级别告警数量、处理时间
• 性能统计：检测周期、响应时间

## 🎮 用户交互接口

### 9. API调用流程

#### 基本使用模式
cpp
// 1. 创建和配置
SystemConfig config = SystemConfig::getDefault();
FleetManager fleet_manager(config);

// 2. 设置回调
fleet_manager.setAlertCallback([](const CollisionAlert& alert) {
    // 处理告警
});

// 3. 初始化数据
fleet_manager.initializeDocks(docks);
fleet_manager.initializeRoutes(routes);

// 4. 启动监控
fleet_manager.runSafetyMonitoring();

// 5. 更新船只状态
fleet_manager.updateBoatState(boat);

// 6. 处理出入坞请求
bool can_undock = fleet_manager.requestUndocking(boat_id, dock_id);


## 🔧 配置与扩展

### 10. 系统配置管理

#### 配置参数
json
{
    "boat": {
        "length": 0.75,              // 船只长度(米)
        "width": 0.47                // 船只宽度(米)
    },
    "emergency_threshold_s": 5,      // 紧急告警阈值(秒)
    "warning_threshold_s": 30,       // 警告告警阈值(秒)
    "max_boats": 30,                 // 最大船只数量
    "min_route_gap_m": 10           // 最小航线间距(米)
}


#### 扩展接口
• 自定义碰撞检测算法
• 自定义告警处理逻辑
• 自定义通信协议
• 自定义决策算法

## 📈 性能特点

### 11. 系统性能指标

• **实时性**: 100ms检测周期，毫秒级告警响应
• **准确性**: 基于精确几何计算的碰撞预测
• **可靠性**: 多重检测机制，冗余告警系统
• **可扩展性**: 支持30船集群，模块化设计
• **标准化**: 基于MQTT/UDP工业标准协议